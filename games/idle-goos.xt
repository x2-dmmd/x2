:: Idle Goos
:: Version x2.1 - x2.1
:: Made by DmmD

:: Imports
imp "pkg/stdlib/color"
imp "pkg/stdlib/cvrt"

:: Public Methods
:: Entry
:main
    :: Start menu
    cls
    out "$(call yellowf \"Welcome To Idle Goos™️\" -)$(call reset -)"
    out "\t$(call bblackf \"- Made by DmmD\" -)$(call reset -)"
    out ""
    out "Press $(call yellowf \"[ENTER]\" -)$(call reset -) to start!"
    out ""
    out "$(call bblackf \"Idle Goos™️ V1.0.0\" -)$(call reset -)"
    out "$(call cursorHide -)"
    pause
    cls

    :: Variables
    psh 0 gees
    psh 0 honks
    psh 0 nests
    psh 0 flocks
    psh 0 lakes

    :: Starts game
    whl 0 == 0 cycle

:: Game cycle
:cycle
    :: Calculates total
    psh 1 total
    mul honks 5 amount
    add total amount total
    mul nests 25 amount
    add total amount total
    mul flocks 100 amount
    add total amount total
    mul lakes 500 amount
    add total amount total

    :: Displays screen
    jmp display

    :: Parses command
    read "> " command
    upr command
    jmp parse

    :: Increases gees
    add gees total gees

:: Displays screen
:display
    :: Clears screen
    cls

    :: Displays costs
    out "$(call yellowf \"Idle Goos™️\" -)$(call reset -)"
    out ""
    out "$(call yellowf \"Gees: \" -)$(call reset -)$(call toStr gees -)"
    out "Gees! A currency for goos!"
    out "You currently earn $(call yellowf \"\" -)$(call toStr total -)$(call reset -) gees per cycle!"
    out ""
    out "$(call format \"honks\" \"[H]onks\" -)"
    out "Honk for your frens to summon $(call yellowf \"5\" -)$(call reset -) extra gees!"
    out ""
    out "$(call format \"nests\" \"[N]ests\" -)"
    out "Call your frens from the nest to summon $(call yellowf \"25\" -)$(call reset -) extra gees!"
    out ""
    out "$(call format \"flocks\" \"[F]locks\" -)"
    out "Look! It's an entire flock of gees! Call them over to summon $(call yellowf \"100\" -)$(call reset -) extra gees!"
    out ""
    out "$(call format \"lakes\" \"[L]akes\" -)"
    out "The lake is where all the gees rest. Let out a giant honk and summon $(call yellowf \"500\" -)$(call reset -) extra gees!"
    out ""
    out ""
    out ""
    out "Press $(call yellowf \"[ENTER]\" -)$(call reset -) to summon a goos!"
    out "Type the ID surrounded in brackets to purchase an item!"

:: Formats string
:format
    :: Variables
    psh _a1 id
    psh _a2 name
    pop "$(pop id)" amount
    call calculate id cost
    psh "" prefix

    :: Formats
    evl gees >= cost "call greenf prefix prefix" "call redf prefix prefix"
    tstr amount
    tstr cost
    psh "$(call yellowf \"\" -)$(pop name): $(call reset -)$(pop amount) $(pop prefix)(Upgrade - $(pop cost) Gees)$(call reset -)" result
    ret result

:: Calculates the costs
:calculate
    psh _a1 -id
    evl -id == "honks" "call _calculateHonks -cost"
    evl -id == "nests" "call _calculateNests -cost"
    evl -id == "flocks" "call _calculateFlocks -cost"
    evl -id == "lakes" "call _calculateLakes -cost"
    ret -cost

:: Parses command
:parse
    psh "" id
    evl command == "H" "psh \"honks\" id"
    evl command == "N" "psh \"nests\" id"
    evl command == "F" "psh \"flocks\" id"
    evl command == "L" "psh \"lakes\" id"
    evl id != "" "jmp _parse"

:: Private Methods
:_calculateHonks
    mul honks 500 -cost
    add -cost 500 -cost
    ret -cost
    
:_calculateNests
    mul nests 10000 -cost
    add -cost 5000 -cost
    ret -cost
    
:_calculateFlocks
    evl flocks < 50 "mul flocks 50000 -cost" "mul flocks 100000 -cost"
    add -cost 50000 -cost
    ret -cost
    
:_calculateLakes
    mul 100000 lakes -cost
    mul -cost lakes -cost
    add -cost 100000 -cost
    ret -cost

:_parse
    out ""
    out "Are you sure you want to purchase some $(call yellowf \"<\" -)$(pop id)>$(call reset -)?"
    read "[Y]es (Default) / [N]o " choice
    upr choice
    evl choice != "N" "jmp _parseCalculate"

:_parseCalculate
    psh "" name
    evl id == "honks" "call _calculateHonks cost"
    evl id == "nests" "call _calculateNests cost"
    evl id == "flocks" "call _calculateFlocks cost"
    evl id == "lakes" "call _calculateLakes cost"
    out ""
    out "How many $(call yellowf \"<\" -)$(pop id)>$(call reset -) would you like to purchase?"
    read "> " amount
    inms amount chk
    evl chk == 1 "jmp _parseAmount" "jmp _parseCalculateFail"

:_parseCalculateFail
    out ""
    out "The amount \"$(call yellowf amount -)$(call reset -)\" is not an integer"
    pause

:_parseAmount
    num amount
    rnd amount
    evl amount <= 0 "jmp _parseAmountFail" "jmp _parseCheck"

:_parseAmountFail
    out ""
    out "You have to buy $(call yellowf \"at least 1 or more <\" -)$(pop id)>$(call reset -)"
    pause

:_parseCheck
    mul amount cost cost
    tstr amount
    tstr cost
    out ""
    out "Are you sure you want to purchase $(call yellowf amount -) <$(pop id)>$(call reset -) for $(call yellowf cost -)$(call reset -) gees?"
    read "[Y]es (Default) / [N]o " choice
    evl choice != "N" "jmp _parseCompare"

:_parseCompare
    num cost
    evl gees < cost "jmp _parseCompareFail" "jmp _parsePurchase"

:_parseCompareFail
    out ""
    out "You need $(call yellowf cost -)$(call reset -) gees to purchase $(call yellowf amount -) <$(pop id)>$(call reset -)"
    out "You currently have $(call yellowf \"\" -)$(call toStr gees -)$(call reset -) gees"
    pause

:_parsePurchase
    num amount
    sub gees cost gees
    pop "$(pop id)" current
    add current amount current
    psh current "$(pop id)"